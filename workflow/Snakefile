#DEK
import yaml
import glob, os, pathlib

#Config file
configfile: "../config/config.yaml"

#Naming format: {sampleID.chemistry}_{basecall_model}_{precorr_method}

samples = config["samples"]
models=["sup","hac"]
#models = config["models"]
precorrs=["noCorr","herro", "dechat"]
#precorrs = config["precorrs"]

#Fxn the get corresponding fast5 files for sample
def get_reads(wildcards):
    return config["samples"][wildcards.sample]

#Fxn to handle fastq vs fasta as input
def choose_path(wildcards):
    if wildcards.precorr == "herro":
        passFile = f"../results/{wildcards.sample}_{wildcards.model}_herro/{wildcards.sample}_{wildcards.model}_{wildcards.precorr}.fasta"
    elif wildcards.precorr == "dechat":
        passFile = f"../results/{wildcards.sample}_{wildcards.model}_{wildcards.precorr}.ec.fa"
    else:
        passFile = f"../results/{wildcards.sample}_{wildcards.model}_{wildcards.precorr}.fastq"
    return passFile

#WIP: Change this to the relevant target files 
rule all:
    input:
        expand("../results/{sample}_{model}_{precorr}.hist", sample=samples, model=models, precorr=precorrs),
        expand("../results/{sample}_{model}_{precorr}_errorCatalog", sample=samples, model=models, precorr=precorrs),
        expand("../results/{sample}_{model}_noCorr_nanoplotNanoStats.txt", sample=samples, model=models)


rule basecall:
    input:
        get_reads
    output:
        "../results/{sample}_{model}_noCorr.fastq"
    params:
        model="{model}",
        dorado = config["dorado_path"]
    log:
        "logs/basecalling/{sample}_{model}.log"
    shell:
        "({params.dorado} basecaller --emit-fastq {params.model} {input} > {output}) 2> {log}"

rule herro_toPaf:
    input:
        "../results/{sample}_{model}_noCorr.fastq"
    output:
        "../results/{sample}_{model}_herro/{sample}_{model}_herro.paf"
    log:
        "logs/herro/{sample}_{model}_toPaf.log"
    params:
        dorado = config["dorado_path"]
    shell:
        "({params.dorado} correct {input} --to-paf > {output}) 2> {log}"

rule herro_correct:
    input:
        paf = "../results/{sample}_{model}_herro/{sample}_{model}_herro.paf",
        reads = "../results/{sample}_{model}_noCorr.fastq"
    output:
        "../results/{sample}_{model}_herro/{sample}_{model}_herro.fasta"
    log:
        "logs/herro/{sample}_{model}_correct.log"
    params:
        dorado = config["dorado_path"]
    shell:
        "({params.dorado} correct {input.reads} --from-paf {input.paf} > {output}) 2> {log}"

rule dechat_correct:
    input:
        "../results/{sample}_{model}_noCorr.fastq"
    output:
        "../results/{sample}_{model}_dechat.ec.fa"
    log:
        "logs/dechat/{sample}_{model}_correct.log"
    conda:
        "envs/dechat.yaml"
    params:
        prefix = "{sample}_{model}_dechat",
        tempdir = temp("../tmp_{sample}_{model}"),
        readscopy = "{sample}_{model}_noCorr.fastq",
        tomove = "{sample}_{model}_dechat.ec.fa"
    shell: #need to isolate each dechat job to avoid overwriting files
        """
        mkdir -p {params.tempdir}
        cp {input} {params.tempdir}
        cd {params.tempdir}
        dechat -t {threads} -i {params.readscopy} -o {params.prefix}
        mv {params.tomove} {output}
        """

rule map_reads:
    input:
        query = choose_path,
        ref = config["ref_genome"]
    output:
        "../results/{sample}_{model}_{precorr}.sam"
    log:
        "logs/minimap/{sample}_{model}_{precorr}.log"
    conda:
        "envs/map_reads.yaml"
    shell:
        "(minimap2 -ax map-ont --MD -t {threads} {input.ref} {input.query} > {output}) 2> {log}"

rule sort_mappings:
    input:
        "../results/{sample}_{model}_{precorr}.sam"
    output:
        "../results/{sample}_{model}_{precorr}.sorted.bam"
    log:
        "logs/minimap/{sample}_{model}_{precorr}.sort.log"
    conda:
        "envs/samtools.yaml"
    shell:
        "(samtools sort -O bam -o {output} -@ {threads} --write-index {input}) 2> {log}"

# rule bam_errors:
#     input: 
#         "../results/{sample}_{model}_{precorr}.sorted.bam"
#     output:
#         directory("../results/{sample}_{model}_{precorr}_errorCatalog") #check what kind output?
#     log:
#         "logs/bam_errors/{sample}_{model}_{precorr}.log"
#     conda:
#         "envs/pomoxis.yaml"
#     params:
#         prefix = "../results/{sample}_{model}_{precorr}_errorCatalog"
#     shell:
#         "(catalogue_errors count -t {threads} -o {params.prefix} {input}) 2> {log}"

rule bam_errors:
    input:
        "../results/{sample}_{model}_{precorr}.sorted.bam"
    output:
        "../results/{sample}_{model}_{precorr}.bamstats.txt"
    log:
        "logs/samtools_stats/{sample}_{model}_{precorr}.log"
    conda:
        "envs/samtools.yaml"
    params:
        ref = config["ref_genome"]
    shell:
        "(samtools stats -@ {threads} --reference {params.ref} {input} > {output}) 2> {log}"

rule count_kmers:
    input:
        choose_path
    output:
        "../results/{sample}_{model}_{precorr}.hist"
    log:
        "logs/jellyfish/{sample}_{model}_{precorr}.log"
    params:
        prefix = "../results/{sample}_{model}_{precorr}.jf",
        jellyfish = config["jellyfish_path"]
    shell:
        """
        {params.jellyfish} count -m 27 -C -t {threads} -s 8G -o {params.prefix} {input}
        {params.jellyfish} histo -t {threads} {params.prefix} > {output}
        """

rule nanoplot:
    input:
        "../results/{sample}_{model}_noCorr.fastq"
    output:
        "../results/{sample}_{model}_noCorr_nanoplotNanoStats.txt"
    log:
        "logs/nanoplot/{sample}_{model}_noCorr.log"
    conda:
        "envs/nanoplot.yaml"
    params:
        prefix = "{sample}_{model}_noCorr_nanoplot",
        outdir = "../results/"
    shell:
        "(NanoPlot -t {threads} -o {params.outdir} -p {params.prefix} --no_static --fastq {input}) 2> {log}"